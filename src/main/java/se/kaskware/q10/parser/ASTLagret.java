/* Generated By:JJTree: Do not edit this line. ASTLagret.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package se.kaskware.q10.parser;

import se.kaskware.q10.parser.helper.LobReference;
import se.kaskware.q10.parser.helper.ProductLineReference;
import se.kaskware.q10.parser.helper.Reference;
import se.kaskware.q10.parser.helper.RuleReference;

import java.util.HashMap;
import java.util.List;

public class ASTLagret extends SimpleNode {
  private HashMap<String, IdentifyableNode> m_products     = new HashMap<>();
  private HashMap<String, IdentifyableNode> m_rules        = new HashMap<>();
  private HashMap<String, IdentifyableNode> m_lobs         = new HashMap<>();
  private HashMap<String, IdentifyableNode> m_productLines = new HashMap<>();

  public ASTLagret(int id) {
    super(id);
  }

  public ASTLagret(PLE_Parser p, int id) {
    super(p, id);
  }

  /** Accept the visitor. **/
  public Object jjtAccept(PLE_ParserVisitor visitor, Object data) {
    return visitor.visit(this, data);
  }

  public void register(ASTProduct product) {
    m_products.put(product.getIdentifier(), product);
    product.setLager(this);
  }

  public void register(ASTLob lob) {
    m_lobs.put(lob.getIdentifier(), lob);
    lob.setLager(this);
  }

  public void register(ASTProductLine productLine) {
    m_productLines.put(productLine.getIdentifier(), productLine);
    productLine.setLager(this);
  }

  public void register(ASTRule rule) {
    m_rules.put(rule.getIdentifier(), rule);
    rule.setLager(this);
  }

  public void resolveReferences() {
    resolveReference(m_products);
    resolveReference(m_lobs);
    resolveReference(m_productLines);
    resolveReference(m_rules);
  }

  protected void resolveReference(HashMap<String, IdentifyableNode> map) {
    for (IdentifyableNode node : map.values()) {
      List<Reference> badRef = node.resolveReferences();
      if (badRef.isEmpty()) continue;
      System.out.println(
          String.format("%s = %s", PLE_ParserTreeConstants.jjtNodeName[node.getId()], node.getIdentifier()));
      for (Reference reference : badRef) {
        System.out.println(String.format("  %s = %s is missing",
                                         reference.getClass().getSimpleName(), reference.getIdentifier()));
      }
    }
  }

  protected boolean referenceExists(LobReference reference) {
    return m_lobs.containsKey(reference.getIdentifier());
  }

  protected boolean referenceExists(ProductLineReference reference) {
    return m_productLines.containsKey(reference.getIdentifier());
  }

  protected boolean referenceExists(RuleReference reference) {
    return m_rules.containsKey(reference.getIdentifier());
  }

  /*
    (LAGRET
      (PRODUCT ...)
      (LOB ...)
      (PRODUCTLINE ...)
      (RULE ...))
   */
  public void localToString(StringBuilder buf, String prefix) {
    buf.append("\n");
    for (IdentifyableNode node : m_products.values()) node.dump(buf, prefix);
    for (IdentifyableNode node : m_lobs.values()) node.dump(buf, prefix);
    for (IdentifyableNode node : m_productLines.values()) node.dump(buf, prefix);
    for (IdentifyableNode node : m_rules.values()) node.dump(buf, prefix);
  }
}
/* JavaCC - OriginalChecksum=28c144f449841199422104d307a032ca (do not edit this line) */
