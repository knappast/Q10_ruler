/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ple_parser.jj */
/*@egen*/
options {
               
                 
                           
                           
                          
  IGNORE_CASE = true;
  JAVA_UNICODE_ESCAPE = false;

  UNICODE_INPUT = false;
//  COMMON_TOKEN_ACTION = true;
  STATIC = false;
//  DEBUG_PARSER = true;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_TOKEN_MANAGER = true;
//  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(PLE_Parser)

package se.kaskware.ruler.parser;

import se.kaskware.ruler.parser.helper.LobReference;
import se.kaskware.ruler.parser.helper.ProductLineReference;
import se.kaskware.ruler.parser.helper.RuleReference;

import java.io.*;
import java.util.List;
import java.util.Properties;

/** This is the grammar for HPL, written in 'jtt'. */
public class PLE_Parser/*@bgen(jjtree)*/implements PLE_ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTPLE_ParserState jjtree = new JJTPLE_ParserState();

/*@egen*/

  public static Properties s_parserProperties;

  private boolean attemptErrorRecovery = false;

  public boolean getAttemptErrorRecovery() {
    return attemptErrorRecovery;
  }
  public void setAttemptErrorRecovery(boolean val) {
    attemptErrorRecovery = val;
  }

  private void handleParseError(ParseException e) throws ParseException {
    System.out.println("========================================================================================");
    System.out.println("Error at line " + getToken(1).beginLine + ": " + getToken(1).image );
    System.out.println("Statement not recognised");
    e.printStackTrace();
//    error_skiptobefore(EOL);
  }

  public String dropCitaionMarks(String str) {
    int start = 0, end = str.length();
    boolean doIt = false;

    if (str.charAt(0) == '"') { start = 1; doIt = true; }
    if (str.charAt(end-1) == '"') { end--; doIt = true; }
    return doIt ? str.substring(start, end): str;  // drop citationmarks if any
  }

  public String getProperty(String varName) {
    String propValue = s_parserProperties.getProperty(varName);
    return System.getProperty(varName, propValue);  // overrides propertiesfile
  }

  public static void loadProperties(String buildProps, String targetProps) {
    try {
      if (s_parserProperties == null) {
        s_parserProperties = new Properties();
        s_parserProperties.load(new FileInputStream(buildProps));
        s_parserProperties.load(new FileInputStream(targetProps));
      }
    }
    catch (IOException e) {
      System.out.println("No hpl.properties file found. Great chance for none functional genarated files.");
    }
  }

  protected boolean checkItemIdentifier(String prefix, String id) {
    int start = id.indexOf('_');
    if (start < 0) return false;
    return prefix.equalsIgnoreCase(id.substring(0, start));
  }

  public static void main(String args[]) throws ParseException, SemanticException {
    PLE_Parser parser;

/*    String args[] = {
      "-spec", m_specFile,
      "-buildprops", m_targetenv,
      "-targetprops", m_properties
    }; */

    if (args.length == 1) {
      String parseFile = null, buildProps = null, targetProps = null;
      try {
        parseFile = args[0];
//        buildProps  = args[1];
//        targetProps = args[2];

        System.out.println("PLE_Parser: Reading product specification from file " + parseFile);

//        loadProperties(buildProps, targetProps);
        parser = new PLE_Parser(new FileInputStream(parseFile));
      } catch (FileNotFoundException e) {
        System.out.println("PLE_Parser:  File " + parseFile + " or " + buildProps  + " or " + targetProps + " not found.");
        return;
      }
    }
    else
      throw new ParseException("PLE_Parser: Usage is"
                               + " 'java PLE_Parser <inputfile> -doWsdl <bool> -doService <bool> -doBuild <bool>"
                               + " -buildProps <propFile> -targetProps <propFile>'");

    try {
      parser.setAttemptErrorRecovery(true);
      long start = System.currentTimeMillis();
      ASTLagret node = parser.lagret();
      System.out.println("parsing took: " + ((System.currentTimeMillis() - start) / 1000.0 ) + " seconds");
      start = System.currentTimeMillis();
      node.resolveReferences();
      System.out.println("resolvning references took: " + ((System.currentTimeMillis() - start) / 1000.0 ) + " seconds");
      node.dump("");

      System.out.println("PLE_Parser:  Parsing completed successfully.");
    } catch (ParseException pe) {
      System.out.println("PLE_Parser:  Encountered errors during parse.");
      pe.printStackTrace();
      throw pe;
    }
//    catch (SemanticException se) {
//      System.out.println("PLE_Parser:  Encountered errors during parse.");
//      se.printStackTrace();
//      throw se;
//    }
  }
}

PARSER_END(PLE_Parser)

SKIP : {
     " "
  |  "\t"
  |  "\n"
  |  "\r"
  |  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
  |  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}


TOKEN : {
   <INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])?
                   | <HEX_LITERAL> (["l","L"])?
                   | <OCTAL_LITERAL> (["l","L"])?>
  |  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
  |  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
  |  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
  |  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
                        | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
                        |     (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
                        |     (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
  |  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
  |  <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"]
                       | "\\" (["n","t","b","r","f","\\","\'","\""]
                       | ["0"-"7"] (["0"-"7"])?
                       | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
  |  <STRING_LITERAL: "\"" (~["\"","\\","\n","\r"]
                    | "\\" (["n","t","b","r","f","\\","\'","\""]
                    | ["0"-"7"] (["0"-"7"])?
                    | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">
  | <NUMBER: <INTEGER_LITERAL> | <FLOATING_POINT_LITERAL>>
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
      < PRODUCT:       "Product" >
    | < DOCUMENTATION: "Documentation" >
    | < VERSION:       "Version" >
    | < SLOGAN:        "Slogan" >
    | < DESCRIPTION:   "Description" >
    | < CHANGEITEMS:   "ChangeItems" >
    | < AUTHOR:        "Author" >
    | < WHEN:          "When" >
    | < LOB:           "LOB" >
    | < PRODLINE:      "Productline" >
    | < RULE:          "Rule" >
    | < DATADICTION:   "DataDictionary" >
    | < COEFFICIENT:   "Coefficient" >
    | < LAGRET:        "Lagret" >
}

TOKEN : /* SEPARATORS */
{
      < COM: "," >
    | < GTT: ">>" >
    | < LB: "[" >
    | < LC: "{" >
    | < LP: "(" >
    | < LT: "<" >
    | < LTT: "<<" >
    | < RB: "]" >
    | < RC: "}" >
    | < RP: ")" >
    | < SEM: ";" >
    | < AT: "@" >
    | < DOL: "$" >
    | < DOT: "." >
    | < UL: "_" >
}

TOKEN : /* OPERATORS */
{
      < AND: "&&" >
    | < COL: ":" >
    | < EQ: "=" >
    | < EQEQ: "==" >
    | < GEQ: ">=" >
    | < GT: ">" >
    | < LEQ: "<=" >
    | < NEQ: "!=" >
    | < NOT: "!" >
    | < MINUS: "-" >
    | < OR: "||" >
    | < PLUS: "+" >
    | < Q: "?" >
    | < SLASH: "/" >
    | < STAR: "*" >
}

TOKEN : {
     <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
  |  <#LETTER: ["A"-"Z","_","a"-"z"]>
  |  <#DIGIT: ["0"-"9"]>
}

/* grammer rules and actions follow */
  ASTLagret lagret()         : {/*@bgen(jjtree) Lagret */
  ASTLagret jjtn000 = new ASTLagret(this, JJTLAGRET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  }
  {/*@bgen(jjtree) Lagret */
     try {
/*@egen*/
     <LP> <LAGRET>
       (
           LOOKAHEAD(2) product()        { jjtn000.register((ASTProduct)jjtree.popNode()); }
         | LOOKAHEAD(2) lob()            { jjtn000.register((ASTLob)jjtree.popNode()); }
         | LOOKAHEAD(2) productLine()    { jjtn000.register((ASTProductLine)jjtree.popNode()); }
         | LOOKAHEAD(2) rule()           { jjtn000.register((ASTRule)jjtree.popNode()); }
         | LOOKAHEAD(2) dataDictionary()
         | LOOKAHEAD(2) coefficienter()
       ) *
      <RP> <EOF>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {
       return jjtn000;
     }/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
  }

  void lob()      : {/*@bgen(jjtree) Lob */
     ASTLob jjtn000 = new ASTLob(this, JJTLOB);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/
     ASTDocumentation doc;
     String lobID;
  }
  {/*@bgen(jjtree) Lob */
      try {
/*@egen*/
      <LP> <LOB> lobID = itemIdentifier("lob")
        doc = documentation()
      <RP>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {
       jjtn000.setIdentifier(lobID);
       jjtn000.setDocumentation(doc);
     }/*@bgen(jjtree)*/
      } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          throw (RuntimeException)jjte000;
        }
        if (jjte000 instanceof ParseException) {
          throw (ParseException)jjte000;
        }
        throw (Error)jjte000;
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
      }
/*@egen*/
  }

  void productLine()              : {/*@bgen(jjtree) ProductLine */
     ASTProductLine jjtn000 = new ASTProductLine(this, JJTPRODUCTLINE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/
     ASTDocumentation doc;
     String prodLineID;
  }
  {/*@bgen(jjtree) ProductLine */
      try {
/*@egen*/
      <LP> <PRODLINE> prodLineID = itemIdentifier("prodLine")
        doc = documentation()
      <RP>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {
       jjtn000.setIdentifier(prodLineID);
       jjtn000.setDocumentation(doc);
     }/*@bgen(jjtree)*/
      } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          throw (RuntimeException)jjte000;
        }
        if (jjte000 instanceof ParseException) {
          throw (ParseException)jjte000;
        }
        throw (Error)jjte000;
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
      }
/*@egen*/
  }

  void rule()       : {/*@bgen(jjtree) Rule */
     ASTRule jjtn000 = new ASTRule(this, JJTRULE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/
     ASTDocumentation doc;
     String ruleID;
  }
  {/*@bgen(jjtree) Rule */
      try {
/*@egen*/
      <LP> <RULE> ruleID = itemIdentifier("rule")
        doc = documentation()
      <RP>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {
       jjtn000.setIdentifier(ruleID);
       jjtn000.setDocumentation(doc);
     }/*@bgen(jjtree)*/
      } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          throw (RuntimeException)jjte000;
        }
        if (jjte000 instanceof ParseException) {
          throw (ParseException)jjte000;
        }
        throw (Error)jjte000;
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
      }
/*@egen*/
  }

  ASTDataDictionary dataDictionary()                 : {/*@bgen(jjtree) DataDictionary */
     ASTDataDictionary jjtn000 = new ASTDataDictionary(this, JJTDATADICTIONARY);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/
     ASTDocumentation doc;
     String ddID;
  }
  {/*@bgen(jjtree) DataDictionary */
      try {
/*@egen*/
      <LP> <DATADICTION> ddID = itemIdentifier("dd")
        doc = documentation()
      <RP>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {
       jjtn000.setIdentifier(ddID);
       jjtn000.setDocumentation(doc);
       return jjtn000;
     }/*@bgen(jjtree)*/
      } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          throw (RuntimeException)jjte000;
        }
        if (jjte000 instanceof ParseException) {
          throw (ParseException)jjte000;
        }
        throw (Error)jjte000;
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
      }
/*@egen*/
  }

  ASTCoefficienter coefficienter()                : {/*@bgen(jjtree) Coefficienter */
     ASTCoefficienter jjtn000 = new ASTCoefficienter(this, JJTCOEFFICIENTER);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/
     ASTDocumentation doc;
     String coffID;
  }
  {/*@bgen(jjtree) Coefficienter */
      try {
/*@egen*/
      <LP> <COEFFICIENT> coffID = itemIdentifier("coff")
        doc = documentation()
      <RP>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {
       jjtn000.setIdentifier(coffID);
       jjtn000.setDocumentation(doc);
       return jjtn000;
     }/*@bgen(jjtree)*/
      } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          throw (RuntimeException)jjte000;
        }
        if (jjte000 instanceof ParseException) {
          throw (ParseException)jjte000;
        }
        throw (Error)jjte000;
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
      }
/*@egen*/
  }

  /*
    (PRODUCT product_2323
      (DOCUMENTATION
        (VERSION "12" "24")
        (SLOGAN "bla bla bla")
        (DESCRIPTION "bla bla bla")
        (CHANGEITEM (((AUTHOR "Per Leander")(WHEN "20170102 18:18")))))
      (LOB lob_353)
      (PRODUCTLINE prodLine_6878)
      (RULE rule_1231))
  */
  void product()          : {/*@bgen(jjtree) Product */
     ASTProduct jjtn000 = new ASTProduct(this, JJTPRODUCT);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/
     ASTDocumentation doc;
     String prodID, lobId, prodLineId, ruleId;
  }
  {/*@bgen(jjtree) Product */
     try {
/*@egen*/
     <LP> <PRODUCT> prodID = itemIdentifier("product")
        doc = documentation()
        <LP> <LOB> lobId = itemIdentifier("lob") <RP>
        <LP> <PRODLINE> prodLineId = itemIdentifier("prodline") <RP>
        <LP> <RULE> ruleId = itemIdentifier("rule") <RP>
      <RP>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {
       jjtn000.setIdentifier(prodID);
       jjtn000.setDocumentation(doc);
       jjtn000.setReference(new LobReference(lobId));
       jjtn000.setReference(new ProductLineReference(prodLineId));
       jjtn000.setReference(new RuleReference(ruleId));
     }/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
  }

/*
  (DOCUMENTATION
    (VERSION "12" "24")
    (SLOGAN "bla bla bla")
    (DESCRIPTION "bla bla bla")
    (CHANGEITEMS (((AUTHOR "Per Leander")(WHEN "20170102 18:18")))))
 */
  ASTDocumentation documentation()                : {/*@bgen(jjtree) Documentation */
     ASTDocumentation jjtn000 = new ASTDocumentation(this, JJTDOCUMENTATION);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/
     ASTDocumentation doc;
     String text;
  }
  {/*@bgen(jjtree) Documentation */
     try {
/*@egen*/
     <LP> <DOCUMENTATION> version(jjtn000) slogan(jjtn000) description(jjtn000) changeItems(jjtn000) <RP>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {
       return jjtn000;
     }/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
  }

  /* (VERSION "12" "24")  */
  void version(ASTDocumentation doc) : {
     int major, minor;
  }
  {
     <LP> <VERSION> major = integer() minor = integer() <RP>
     {
        doc.setVersion(major, minor);
     }
  }

  /* (SLOGAN "bla bla bla") */
  void slogan(ASTDocumentation doc) : {
     String text;
  }
  {
     <LP> <SLOGAN> text = string() <RP>
     {
        doc.setSlogan(text);
     }
  }

  /* (DESCRIPTION "bla bla bla") */
  void description(ASTDocumentation doc) : {
     String text;
  }
  {
     <LP> <DESCRIPTION> text = string() <RP>
     {
        doc.setDescription(text);
     }
  }

  /* (CHANGEITEM (((AUTHOR "Per Leander")(WHEN "20170102 18:18"))))) */
  void changeItems(ASTDocumentation doc) : {
     ASTChangeItem item;
  }
  {
     <LP> <CHANGEITEMS>
       <LP> ( changeItem() { doc.addChangeItem((ASTChangeItem)jjtree.popNode()); } )* <RP>
     <RP>
     {
     }
  }

  /* (CHANGEITEM (((AUTHOR "Per Leander")(WHEN "20170102 18:18"))))) */
  void changeItem()             : {/*@bgen(jjtree) ChangeItem */
     ASTChangeItem jjtn000 = new ASTChangeItem(this, JJTCHANGEITEM);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
/*@egen*/
     String name, date;
  }
  {/*@bgen(jjtree) ChangeItem */
     try {
/*@egen*/
     <LP> <LP> <AUTHOR> name = string() <RP> <LP> <WHEN> date = string() <RP>  <RP>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {
        jjtn000.setChange(name, date);
     }/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
  }

//   ASTValueString description() : {
//      ASTValueString doc;
//   }
//   {
//      <DESCRIPTION> doc = valueString() { return doc; }
//   }

   ASTValueble valueble()           : {/*@bgen(jjtree) Valueble */
      ASTValueble jjtn000 = new ASTValueble(this, JJTVALUEBLE);
      boolean jjtc000 = true;
      jjtree.openNodeScope(jjtn000);
/*@egen*/
      ASTValue val;
      ASTVariable var;
   }
   {/*@bgen(jjtree) Valueble */
     try {
/*@egen*/
     (  val = value()    { jjtn000.setValue(val); return jjtn000; }
      | var = variable() { jjtn000.setVariable(var); return jjtn000; }
     )/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {
       return jjtn000;
     }/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
   }

   ASTValue value()        : {/*@bgen(jjtree) Value */
      ASTValue jjtn000 = new ASTValue(this, JJTVALUE);
      boolean jjtc000 = true;
      jjtree.openNodeScope(jjtn000);
/*@egen*/
      ASTValueString strValue;
      int intValue;
      ASTVariable var;
   }
   {/*@bgen(jjtree) Value */
     try {
/*@egen*/
     (  strValue = valueString() { jjtn000.setValue(strValue); }
      | intValue = integer()     { jjtn000.setValue(intValue); }
     )/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {
       return jjtn000;
     }/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
   }

   ASTValueString valueString()              : {/*@bgen(jjtree) ValueString */
      ASTValueString jjtn000 = new ASTValueString(this, JJTVALUESTRING);
      boolean jjtc000 = true;
      jjtree.openNodeScope(jjtn000);
/*@egen*/
      String str;
   }
   {/*@bgen(jjtree) ValueString */
      try {
/*@egen*/
      str = string()/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ { jjtn000.setValue(str); jjtree.popNode(); return jjtn000; }/*@bgen(jjtree)*/
      } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          throw (RuntimeException)jjte000;
        }
        if (jjte000 instanceof ParseException) {
          throw (ParseException)jjte000;
        }
        throw (Error)jjte000;
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
      }
/*@egen*/
   }

   ASTVariable variable()           : {/*@bgen(jjtree) Variable */
      ASTVariable jjtn000 = new ASTVariable(this, JJTVARIABLE);
      boolean jjtc000 = true;
      jjtree.openNodeScope(jjtn000);
/*@egen*/
      String idName, func, key;
      ASTValueble val;
   }
   {/*@bgen(jjtree) Variable */
     try {
/*@egen*/
     (
       LOOKAHEAD(2)
        <DOL> <LC> idName = identifier() <RC>  { jjtn000.setVariable(idName); }
      | <DOL> func = identifier() <LP> key = string() <COM> val = valueble() <RP>
        {
         jjtn000.setFunction(func, key, val);
        }
     )/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {
       return jjtn000;
     }/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/

   }

   String itemIdentifier(String prefix)  : {
      Token id;
      String idName;
   }
   {
     id = <IDENTIFIER>
     {
       idName = id.image;
       if (! checkItemIdentifier(prefix, idName))
         throw new Error(String.format("Not a valid item identifier: %s. Should include: %s", idName, prefix));
       return idName;
     }
   }

   String identifier()  : { // do I need a specific class? For checking with a symtable ...
      Token id, part;
      String idName;
   }
   {
     id = <IDENTIFIER> { idName = id.image; } ( <DOT> part = <IDENTIFIER> { idName += "." + part.image; } )*
     {
        return idName;
     }
   }

   String string() : {
      Token tok; String str;
   }
   {
       tok = <STRING_LITERAL> { str = dropCitaionMarks(tok.image); }
     ( <PLUS> tok = <STRING_LITERAL> { return str += dropCitaionMarks(tok.image); })*
     { return str; }
   }

   int integer() : {
      Token num;
   }
   {
      num = <INTEGER_LITERAL> { return Integer.parseInt(num.image); }
   }